<script src="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js"></script>
<script>
  let pyodide = null;
  let pyodideReady = false;

  async function initPyodide() {
    const status = document.getElementById('py-status');
    const progress = document.getElementById('progress');
    status.textContent = 'Loading quantum engine...';
    
    // Show progress bar
    progress.style.display = 'block';
    let width = 0;
    const interval = setInterval(() => {
      width = (width + 1) % 101;
      progress.style.background = `linear-gradient(to right, #00f ${width}%, #333 ${width}%)`;
    }, 80);

    try {
      pyodide = await loadPyodide({
        // Optional: Show download progress
        stdout: (text) => console.log(text),
        fullStdLib: false
      });
      await pyodide.loadPackage("numpy");
      
      clearInterval(interval);
      progress.style.background = '#0f0';
      setTimeout(() => {
        progress.style.background = '#333';
        progress.style.display = 'none';
      }, 500);

      status.textContent = 'Quantum engine ready!';
      setTimeout(() => status.style.display = 'none', 1500);
      pyodideReady = true;
      document.getElementById('collapse').disabled = false;
    } catch (e) {
      clearInterval(interval);
      progress.style.background = '#f55';
      status.textContent = 'Error: ' + e.message;
      status.style.color = '#f55';
    }
  }

  // === REST OF YOUR CODE (unchanged below) ===
  const slider = document.getElementById('noise-slider');
  const noiseValue = document.getElementById('noise-value');
  const collapseBtn = document.getElementById('collapse');
  const predictBtn = document.getElementById('predict-flare');
  const resultDiv = document.getElementById('result');
  const flareDiv = document.getElementById('flare-status');
  const canvas = document.getElementById('flux-chart');
  const ctx = canvas.getContext('2d');
  const progress = document.getElementById('progress');

  slider.addEventListener('input', () => noiseValue.textContent = slider.value);

  collapseBtn.addEventListener('click', async () => {
    if (!pyodideReady) {
      resultDiv.textContent = "Quantum engine still loading...";
      return;
    }
    const gamma = parseFloat(slider.value);
    collapseBtn.disabled = true;
    collapseBtn.textContent = "Running...";
    resultDiv.textContent = "";
    resultDiv.classList.remove('pulse');

    let width = 0;
    const interval = setInterval(() => {
      width = (width + 2) % 101;
      progress.style.background = `linear-gradient(to right, #00f ${width}%, #333 ${width}%)`;
      progress.style.display = 'block';
    }, 50);

    try {
      const code = `
import numpy as np
psi = np.array([1,0,0,1],dtype=complex)/np.sqrt(2)
rho = np.outer(psi,psi.conj())
gamma = ${gamma}
dt = 0.05
steps = 200
for _ in range(steps):
    p = 1-np.exp(-gamma*dt)
    rho[1,1] *= (1-p); rho[2,2] *= (1-p)
    rho[0,0] += p*(rho[1,1]+rho[2,2])
    rho[0,3] *= np.exp(-gamma*dt/2)
    rho[3,0] = rho[0,3].conj()
    rho /= np.trace(rho)
def corr(t1,t2):
    M1 = np.cos(t1)*np.diag([1,-1])+np.sin(t1)*np.array([[0,1],[1,0]])
    M2 = np.cos(t2)*np.diag([1,-1])+np.sin(t2)*np.array([[0,1],[1,0]])
    return np.real(np.trace(np.kron(M1,M2)@rho))
S = corr(0,np.pi/4)+corr(0,-np.pi/4)+corr(np.pi/2,np.pi/4)-corr(np.pi/2,-np.pi/4)
ideal = 2*np.sqrt(2)
loss = (ideal-abs(S))/ideal*100
out = f"CHSH S = {S:.4f} (max 2.828, classical ≤2)\\n"
out += f"Noise Impact: {loss:.1f}% loss\\n\\n"
out += "SPOOKY LINK SURVIVED" if abs(S)>2 else "SPOOKY LINK BROKEN"
print(out)
`;
      await pyodide.runPython(code);
      const output = pyodide.globals.get('out');
      clearInterval(interval);
      progress.style.background = '#333';
      progress.style.display = 'none';
      resultDiv.innerText = output;
      if (output.includes('S =') && parseFloat(output.match(/S = ([-\d.]+)/)[1]) > 2) {
        resultDiv.classList.add('pulse');
      }
    } catch (err) {
      clearInterval(interval);
      resultDiv.innerText = "Error: " + err.message;
    } finally {
      collapseBtn.textContent = "Collapse Again";
      collapseBtn.disabled = false;
    }
  });

  let fluxData = [];
  async function fetchSolarData() {
    flareDiv.textContent = "Fetching solar data...";
    flareDiv.style.color = "#ff0";
    const url = 'https://services.swpc.noaa.gov/json/goes/primary/xrays-1-minute.json';
    try {
      const resp = await fetch(url, { cache: "no-store" });
      if (!resp.ok) throw new Error();
      const data = await resp.json();
      const now = Date.now();
      fluxData = data
        .map(p => ({ t: new Date(p.time_tag).getTime(), f: parseFloat(p.flux) || 0 }))
        .filter(p => p.f > 0 && (now - p.t) <= 30*60*1000)
        .sort((a,b) => a.t - b.t);
      drawChart();
      predictFlare();
    } catch (e) {
      flareDiv.textContent = "Solar data failed — retrying...";
      flareDiv.style.color = "#f55";
      setTimeout(fetchSolarData, 10000);
    }
  }

  function drawChart() {
    ctx.clearRect(0,0,400,120);
    if (fluxData.length < 2) {
      ctx.fillStyle = '#666'; ctx.font = '12px monospace'; ctx.fillText('No data', 180, 60);
      return;
    }
    const t = fluxData.map(p => p.t), f = fluxData.map(p => p.f);
    const minT = Math.min(...t), maxT = Math.max(...t);
    const minF = Math.min(...f), maxF = Math.max(...f) || minF + 1e-10;
    const w = 320, h = 80, padX = 40, padY = 20;
    ctx.strokeStyle = '#0f0'; ctx.lineWidth = 2; ctx.beginPath();
    fluxData.forEach((p,i) => {
      const x = padX + (p.t - minT)/(maxT - minT) * w;
      const y = 100 - padY - (p.f - minF)/(maxF - minF) * h;
      i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
    });
    ctx.stroke();
  }

  function predictFlare() {
    if (fluxData.length < 10) {
      flareDiv.textContent = "Flare prob: —";
      collapseBtn.classList.remove('warn');
      return;
    }
    const recent = fluxData.slice(-5);
    const dt = (recent[recent.length-1].t - recent[0].t) / 1000;
    const slope = dt > 0 ? (recent[recent.length-1].f - recent[0].f) / dt : 0;
    const mean = fluxData.slice(-30).reduce((a,b) => a + b.f, 0) / 30;
    const z = -8.2 + 1.8 * mean + 3.5 * slope;
    const prob = 1 / (1 + Math.exp(-z));
    const pct = (prob * 100).toFixed(1);
    flareDiv.textContent = `Flare prob (30 min): ${pct}%`;
    flareDiv.style.color = prob > 0.6 ? '#f55' : '#ff0';
    if (prob > 0.6) collapseBtn.classList.add('warn');
    else collapseBtn.classList.remove('warn');
  }

  predictBtn.addEventListener('click', fetchSolarData);
  setInterval(fetchSolarData, 120000);
  initPyodide().then(fetchSolarData);
</script>
